<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <style>
        body {
            background-color: white;
            padding: 15%;
            width: 70%;
            min-width: 70%;
            float: left;
            margin: auto;
            text-align: left;
            font-weight: 300;
            font-family: 'Open Sans', sans-serif;
            color: #121212;
        }

        .emphasis {
            text-decoration: underline;
        }


        h1, h2, h3, h4 {
            font-family: 'Source Sans Pro', sans-serif;
        }

        kbd {
            color: #121212;
        }
    </style>
    <title>CS 284A: Pathtracer 1</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">

    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
    </script>

</head>


<body>

<h1 align="middle">CS 284A: Computer Graphics and Imaging, Spring 2023</h1>
<h1 align="middle">Project 3-1: Pathtracer</h1>
<h2 align="middle">IRINA HALLINAN & CECIL SYMES</h2>
<!-- Add Website URL -->
<h3 align="middle">Website URL: <a href="https://irina694.github.io/cs284-sp23-projects/proj3-1/">https://irina694.github.io/cs284-sp23-projects/proj3-1</a>
</h3>
<br><br>

<div>


    <h2 align="middle">Overview</h2>
    <p>
	<p>
		In this project, we implement physics-based rendering using path-tracing techniques. Specifically, we
		implemented 5 parts.
	</p>
	<ul>
		<li>In <span class="emphasis">Part 1</span> we generated a ray from the virtual camera and implemented
			primitives-ray intersections like sphere-ray and triangle-ray.
		</li>
		<li>In <span class="emphasis">Part 2</span> we implemented an optimization based on a Bounding Volume Hierarchy
			representation of objects to render our scenes more efficiently.
		</li>
		<li>In <span class="emphasis">Part 3</span> we calculated direct illumination using Monte Carlo Estimator, which
			happens when light goes from a light source directly into the camera or bounces off an object and then goes
			into the camera.
		</li>
		<li>In <span class="emphasis">Part 4</span> we implemented global illumination by recursively bouncing rays of
			light until they probabilistically stop with the Russian Roulette algorithm.
		</li>
		<li>In <span class="emphasis">Part 5</span> we implemented adaptive sampling to render images with less noise.
		</li>
	</ul>
	The details of each part are below.
	</p>
    </p>

    <br>

    <h2 align="middle">Part 1: Ray Generation and Scene Intersection (20 Points)</h2>
    <!-- Walk through the ray generation and primitive intersection parts of the rendering pipeline.
    Explain the triangle intersection algorithm you implemented in your own words.
    Show images with normal shading for a few small .dae files. -->

    <h3>
        Walk through the ray generation and primitive intersection parts of the rendering pipeline.
    </h3>
    <p>
        For Part 1, we start with generating a ray, given to us by the normalized <code>(x, y)</code> 2D image coordinate. We have two coordinate systems: the 3D world coordinate
        For Part 1, within <code>Pathtracer::raytrace_pixel</code>, each pixel is iterated over, and <code>ns_aa</code> rays are generated for each pixel using the <code>Camera::generate_ray</code> function. We generate a ray using the normalized <code>(x, y)</code> 2D image coordinate. We have two coordinate systems: the 3D world coordinate system where objects are located, and the 3D camera coordinate system.
    </p>

    <p>First, we convert the given normalized image coordinate into the camera coordinate system, using the helper function <code>Camera::image_to_camera_coordinate</code>. We know where the camera is located in the world coordinate system with respect to the third axis (<code>z</code>), so we need to find what <code>x</code> and <code>y</code> are in the camera space. To do that, we scale the <code>x</code> and <code>y</code> coordinates by the image size, since we know that the camera space spans from <code>-tan(hFov/2)</code> to <code>tan(nFov/2)</code> in the <code>x</code>-direction, and from <code>-tan(vFov/2)</code> to <code>tan(vFov/2)</code> in the <code>x</code>-direction. The <code>hFov</code> is the angle of the horizontal field of view and <code>vFov</code> is the angle of the field of view in the vertical dimension. Given the coordinate <code>(x,y)</code> in camera space, we find the direction of the ray. The direction of the ray is from the camera origin <code>(0, 0, 0)</code> through the point where ray intersected the sensor plate, in camera coordinate system.
    </p>

    <p>Next, we convert the ray from camera to world coordinates. We set the ray's origin as the camera's position in world space and we normalize the direction of the ray in world coordinate system. Finally, we set the ray's minimum time to the near clipping plane, and ray's maximum time to the far clipping plane, since rays outside the camera clipping planes are invisible to the camera.
    </p>

    <p>The image below shows a diagram of the image to camera conversion. </p>

    <div align="middle">
        <img src="images/t1_image_camera_planes.png" align="middle" width="75%"/>
        <figcaption>The diagram of image to camera coordinate conversion for a ray in a scene (credit:
		<a href="https://cs184.eecs.berkeley.edu/sp23/docs/proj3-1-part-1" target="_blank">project spec</a>
		)</figcaption>
    </div>

	<p>
		Triangle primitive intersection is largely covered under the next writeup heading below, so the Sphere primitive intersection is discussed here.
		<br><code>Sphere::intersect</code> is the top-level function call, and calls the other two functions used for detecting a <code>Sphere</code> intersection. The main purpose of this function is to verify if a valid intersection has occurred by calling the other two <code>Sphere</code> methods, and it then updates the passed in <code>Intersection</code> object with the corresponding data, and returns a <code>bool</code> indicating if there was a succesful intersection.
    </p>

    <p><code>Sphere::has_intersection</code> is a straightforward function, and returns a <code>bool</code> indicating if there has been <i>any</i> valid intersection with the Sphere primitive. This is used by other Sphere methods to check if it's worth doing futher intersection computation.
    </p>

	<p><code>Sphere::test</code> checks the validity of the intersection. It does this by following the formulae shown on
		<a href="https://cs184.eecs.berkeley.edu/sp23/lecture/9-23/intro-to-ray-tracing-and-acceler">this lecture slide</a>.
		The two t values are calculated. If they are equal, the ray is tangent. If they are different, then they're sorted so t1 is smaller than t2. The ray is then checked if it is at least partially within the sphere. If so, an intersection is detected. This logic portion was updated when working on Part 3, as we realised rays that were originating inside the sphere were not properly detecting a collision on the inside surface, and would treat the sphere as though it were transparent. The function then assigns t1 and t2 to the input t arguments, and returns a <code>bool</code> indicating if a valid intersection was found.
	</p>

    <p>Image below illustrates the sphere-ray intersection diagram.</p>

    <div align="middle">
        <img src="images/t1_ray_sphere_intersection.png" align="middle" width="75%"/>
        <figcaption>The diagram of ray-sphere intersection (credit:
            <a href="https://cs184.eecs.berkeley.edu/sp23/lecture/9-23/intro-to-ray-tracing-and-acceler" target="_blank">CS 284A Spring 23, lecture 9, slide 23</a>
            )</figcaption>
    </div>

    <br>

    <h3>
        Explain the triangle intersection algorithm you implemented in your own words.
    </h3>
    <p>
        The triangle intersection algorithm was largely based on the concepts from <a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/barycentric-coordinates.html">this webpage</a>, however all code in our project was written by us.</p>

    <p>The function <code>Triangle::has_intersection</code> uses the Inside-Outside test to determine if a point is within a triangle. First, the normal of the triangle's plane is calculated by finding the cross product between any 2 of the 3 vectors between the triangle's vertices. The ray's t value when intersecting this plane is checked, and if the t value is invalid (less than zero, outside of the ray's min_t/max_t values) then the function returns false. If the ray does intersect the plane, then the Inside-Outside test is done.
    </p>

	<div align="middle">
		<img src="images/p1_inside_outside.png" align="middle" width="40%"/>
		<figcaption>Triangle with 3 vertices, and p' representing the ray's intersection point. The blue circle represents the normal of the triangle's plane, coming out of the page due to the counter-clockwise winding of the triangle. The blue normal would be going into the page if the winding was clockwise.</figcaption>
    </div>

    <p>
	In the image above, we can see the triangle has a counter-clockwise winding, moving from p1 through to p3. The normal given by (p2 - p1)x(p3 - p1) points out of the page. If the winding was clockwise, then the normal would go into the page. The test consists of finding the cross product between (p2 - p1)x(p' - p1). If the point is to the left of the (p2 - p1) vector, then the cross product will also come out of the page. We can then find the dot product between the plane's normal, and the cross product given by (p2 - p1)x(p' - p1). If the result is above 0, we know they are both pointing in the same direction, out of the page. This test is then repeated for the other 2 possible vector combinations, ensuring that the dot product between (p3 - p2)x(p' - p2) and the plane's normal is above 0, and finally that the dot product between (p1 - p3)x(p' - p3) and the plane's normal is also above 0. Inverting the winding changes the direction of the plane's normal, but it also changes the direction of each cross product, so the test remains valid.</p>

	<p>If all these tests pass, we know the point is on the plane, the t value is valid, and the point is within the three triangle vertices.
	</p>

	<p>
	<code>Triangle::intersect</code> calls <code>Triangle::has_intersect</code> to see if it should interpolate the normals of its vertices. If there is an intersection, then we use the method outlined in the link above to calculate the Barycentric coordinates. The method requires calculating the areas of each sub-triangle around p', and dividing it over the total area of the triangle, and this ratio is the corresponding Barycentric coordinate. This method also takes advantage of the fact that the area of a triangle is half the area of the parallelogram formed by taking the cross product of two of its edges. As the Barycentric coordinates are based on the <i>ratio</i> of the sub-triangle areas over the total area, we can simply skip dividing the cross product by 2, and we can also skip calculating the 3rd sub-triangle area, as it can simply be inferred from the other 2 Barycentric coordinates. Once we have the Barycentric coordinates, we multiply them against their corresponding vertex's normal, then populate the provided <code>Intersection</code> object argument, and return <code>true</code>.
	</p>

    <h3>
        Show images with normal shading for a few small .dae files.
    </h3>
	
    <!-- Example of including multiple figures -->
    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/p1_teapot.png" align="middle" width="90%;"/>
                    <figcaption>teapot.dae</figcaption>
                </td>
                <td>
                    <img src="images/p1_cube.png" align="middle" width="90%;"/>
                    <figcaption>cube.dae</figcaption>
                </td>
            </tr>
        </table>
    </div>
    <br>


    <h2 align="middle">Part 2: Bounding Volume Hierarchy (20 Points)</h2>
	<!-- Walk through 	your BVH construction algorithm. Explain the heuristic you chose for picking the splitting point.
	Show images with normal shading for a few large .dae files that you can only render with BVH acceleration.
	Compare rendering times on a few scenes with moderately complex geometries with and without BVH acceleration. Present your results in a one-paragraph analysis. -->

    <h3>
        Walk through your BVH construction algorithm. Explain the heuristic you chose for picking the splitting
        point.
    </h3>
    <p>
        In Part 2, we implemented Bounding Volume Hierarchy (BVH), to speed up how ray-object intersections are calculated in a scene. BVH is a recursive method to partition objects that alleviates inefficiency of a naive method of checking if a ray intersects every object. Our BVH implementation created a significant speed-up of rendering. Without BVH, the running complexity for calculating a ray-object intersection is <code>O(N)</code>. With BVH, the running complexity becomes <code>O(log_2(N))</code>. With BVH, we can render .dae files that are made of hundreds of thousands of triangles within seconds, which were infeasible to render without BVH.
    </p>

	<p>We constructed our BVH as follows:</p>

	<p>We construct the BVH recursively. We construct the root node and point its <code>start</code> and <code>end</code> properties to the given list of primitives. We then compute the bounding box for all primitives and count how many primitives there are. The figure below shows an example of the BVH, visualized on the <code>cow.dae</code> file. The left part of the BVH is highlighted in red.
	</p>

    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/t2_bvh.png" align="middle" width="50%;"/>
                    <figcaption>The <code>cow.dae</code> in BVH Visualizer mode</figcaption>
                </td>
            </tr>
        </table>
    </div>

	<p>
	In the base case, if the number of primitives is less than maximum leaf size, we set the start and end pointers of the node to return.</p>
    <p></p>Otherwise, we get the median primitive by dividing the total primitive count by 2.Then, we sort all primitives. This is done by seeing which bounding box axis is the largest, then sorting it along this axis. We created custom functions to compare the centroids of bounding boxes (<code>sortByX</code>, <code>sortByY</code>, and <code>sortByZ</code>), which take the corresponding axis value for the input primitive's centroid, and returns true if the first item is smaller than the second item.</p>
    <p>The downside of this method is that we need to sort all the primitives every recursive call. Although this isn't very efficient, it is necessary because a child bounding box isn't guaranteed to have the same largest axis as its parent.</p>
    <p>Once the list is sorted, we recursively call the <code>construct_bvh</code> function on the left and right side, which become the left and right nodes of the root node. The two halves are created from the sorted list divided at the median primitive.</p>
    <p> Our debugging journey included the following:</p>
    <ul>
        <li>It took a while to realise that end() iterators point to the element AFTER the end, so there was no need to add + 1 to the start of the right child bounding box function call</li>
        <li>At first, the idea was to take the average value of centroids, but it became clear that it was pretty common for almost all of the centroids in current bounding box to share an average centroid value, meaning that one child would be empty, and an infinite loop would occur. Sorting by median means it is guaranteed that child nodes have an equal number of primitives.</li>
        <li>At first, we created a new vector of primitive pointers on the heap when reaching the base case, but then we realised that sorting in place was possible, more memory efficient, and avoided any potential memory leaks.</li>
    </ul>

    <h3>
        Show images with normal shading for a few large .dae files that you can only render with BVH acceleration.
    </h3>

    <p>Below are images that were generated by running the renderer with BVH using 8 threads. The maxplanck.dae contains over 50k primitives. The lucy.dae contains over 130k primitives. Both images are 800 x 600 pixels.</p>
    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/t2_maxplanck.png" align="middle" width="90%;"/>
                    <figcaption>maxplanck.dae</figcaption>
                </td>
                <td>
                    <img src="images/t2_lucy.png" align="middle" width="90%;"/>
                    <figcaption>lucy.dae</figcaption>
                </td>
            </tr>
        </table>
    </div>
    <br>

	<h3>
	  Compare rendering times on a few scenes with moderately complex geometries with and without BVH acceleration. Present your results in a one-paragraph analysis.
	</h3>
	<p>To compare the efficiency of using the BVH, we timed several images being rendered by the same number of rays, using the same number of threads. We used the default values for number of samples and light rays to time the execution: 8 threads, 1 sample per pixel, and 1 light ray, keeping the output image size constant (800x600 pixels). Starting with the simplest cube, which has 12 primitives, there was no speedup. The time to sort the primitives in this small case offset the speedup in traversing the BVH tree. As expected, we see a significant speedup for more complex scenes. Some scenes are divided more evenly, like <code>maxplanck.dae</code> or <code>dragon.dae</code>. The exception where speedup was not as big is <code>building.dae</code>, a scene with a large number of primitives concentrated in one part of the scene. The BVH speedup in this scene was about 30 times, compared to no BVH.</p>


    <table border="1px solid black;">
            <thead>
                <tr>
                    <td>
                        Filename
                    </td>
                    <td>
                        # of primitives
                    </td>
                    <td>
                        # of rays
                    </td>
                    <td>
                        # threads
                    </td>
                    <td>
                        Resolution (pixels)
                    </td>
                    <td>
                        With BVH (seconds)
                    </td>
                    <td>
                        Without BVH (seconds)
                    </td>
                    <td>
                        Speedup (times)
                    </td>
                </tr>
            </thead>
            <tbody>
            <tr>
                <td>
                    cube.dae
                </td>
                <td>
                    12
                </td>
                <td>
                    176,768
                </td>
                <td>
                    8
                </td>
                <td>
                    800x600
                </td>
                <td>
                    0.093072
                </td>
                <td>
                    0.091904
                </td>
                <td>
                    0.9875
                </td>
            </tr>
            <tr>
                <td>
                    bunny.dae
                </td>
                <td>
                    33,696
                </td>
                <td>
                    418,721
                </td>
                <td>
                    8
                </td>
                <td>
                    800x600
                </td>
                <td>
                    0.313027
                </td>
                <td>
                    32.3483
                </td>
                <td>
                    103.3403
                </td>
            </tr>
            <tr>
                <td>
                    building.dae
                </td>
                <td>
                    39,506
                </td>
                <td>
                    205,141
                </td>
                <td>
                    8
                </td>
                <td>
                    800x600
                </td>
                <td>
                    0.33361
                </td>
                <td>
                    9.64124
                </td>
                <td>
                    28.8997
                </td>
            </tr>
            <tr>
                <td>
                    maxplanck.dae
                </td>
                <td>
                    50,801
                </td>
                <td>
                    296,593
                </td>
                <td>
                    8
                </td>
                <td>
                    800x600
                </td>
                <td>
                    0.422581
                </td>
                <td>
                    64.7466
                </td>
                <td>
                    153.2170
                </td>
            </tr>
            <tr>
                <td>
                    dragon.dae
                </td>
                <td>
                    100,012
                </td>
                <td>
                    247,522
                </td>
                <td>
                    8
                </td>
                <td>
                    800x600
                </td>
                <td>
                    0.826029
                </td>
                <td>
                    108.905
                </td>
                <td>
                    131.8416
                </td>
            </tr>
            </tbody>
    </table>

	<br>

    <h2 align="middle">Part 3: Direct Illumination (20 Points)</h2>
    <!-- Walk through both implementations of the direct lighting function.
    Show some images rendered with both implementations of the direct lighting function.
    Focus on one particular scene with at least one area light and compare the noise levels in soft shadows when rendering with 1, 4, 16, and 64 light rays (the -l flag) and with 1 sample per pixel (the -s flag) using light sampling, not uniform hemisphere sampling.
    Compare the results between uniform hemisphere sampling and lighting sampling in a one-paragraph analysis. -->

    <h3>
        Walk through both implementations of the direct lighting function.
    </h3>
	<p>
	<i>Zero Bounce Radiance</i><br>
	The <code>zero_bounce_radiance</code> function is meant to sample visible light sources within the scene, such as area lights. The function is fairly straightforward, and consists of simply retrieving the emission of any surface it intersects with. This emission is then multiplied by the cosine theta of the angle between the normal of the light, and the reverse direction of the incoming ray. This is calculated in the worldspace of the object being hit, and is the implementation of Lambert's cosine law, which is also included in the other radiance functions in Parts 3 and 4. This cosine theta value is not clamped, and is instead the absolute value is taken, as we assume that area lights are emissive on both the top and bottom side.
	</p>

	<p>
	<i>One Bounce Radiance - Uniform Hemisphere Sampling</i><br>
	The implementation of the <code>one_bounce_radiance</code> function consists of checking whether the <code>-H</code> flag is raised when the <code>pathtracer.exe</code> is invoked. The corresponding function is then called based on this flag.
    </p>

	<p>If <i>uniform hemisphere</i> sampling is selected, then the <code>estimate_direct_lighting_hemisphere</code> function is called. In this function, the number of samples taken, <code>num_samples</code>, is calculated by multiplying the number of lights in the scene by the number of samples per area light. This is done to maintain consistency between <code>estimate_direct_lighting_hemisphere</code> and <code>estimate_direct_lighting_importance</code>. Before this function can be described further, <code>bsdf::sample_f</code> must be explained.
    </p>

	<p><code>DiffuseBSDF::sample_f:</code> This function takes in the direction of the ray from the camera, <code>wo</code>, and produces a new direction for an outgoing ray, <code>wi</code>. The function also provides the probability of the ray heading in this certain direction, <code>pdf</code>. The function then finally returns the reflectance of the surface determined by the incoming and outgoing ray directions. This is done by calling the function <code>DiffuseBSDF::f</code>. Our implementation for <code>DiffuseBSDF::f</code> simply returns a constant, which is the reflectance of the bsdf divided by pi, as explained in <a href="https://cs184.eecs.berkeley.edu/sp20/lecture/14-6/intro-to-material-modeling">this slide</a>. This is due to the BSDF being specifically for a diffuse surface, which always scatters incoming light in a uniform hemisphere. This uniform hemisphere reflectance is also reflected in our <code>pdf</code> always being 1/2pi, which is one over the solid angle of a hemisphere. The <code>wi</code> returned is also generated randomly by calling the <code>sampler</code> method within the <code>BSDF</code> class.
    </p>

	 <p>The <code>sample_f</code> call within <code>one_bounce_radiance</code> is used to provide the reflectance, as well as a new direction for our outgoing ray. This direction <code>wi</code> is converted from object to world space, and then it is checked for a collision using the <code>bvh::intersect</code> function. <code>bvh::intersect</code> returns <code>true</code> if an intersection is detected with a specified ray, and it also populates the provided <code>Intersection</code> struct. If an intersection is detected, the function returns <code>true</code> and we use the information inside the <code>Intersection</code> to calculate the emission of the intersected object, and the cosine theta of the angle of incidence, similar to <code>zero_bounce_radiance</code>. This cosine theta value is clamped to ensure that we only consider positive illuminance values. The cosine theta of the incoming radiance from the light onto the surface is also considered, and is also clamped. The radiance is also divided by the distance to the light, which is given by the t value of the new intersection object. This is done to emulate the phenomenon of light intensity falloff in real life.  As mentioned in lectures, the radiance is only divided by the distance and not the distance squared, as it actually looks better this way. Finally, the radiance from the light in this specific direction is multiplied by the returned reflectance of the current surface, as well as the corresponding cosine theta values, and is divided by the pdf, or the chance of the ray being sent in that direction. The function returns the cumulative radiance of all the different light samples returned by rays sent from the current surface hit point.
	<p>

	<div align="middle">
		<img src="images/t3.3_diagram.png" align="middle" width="100%;"/>
		<figcaption>Diagram of our <code>one_bounce_radiance</code> function. <code>theta_camera</code> is taken care of in our <code>BSDF::f</code> function. <code>theta_i</code> and <code>theta_light</code> are calculated using the object spaces generated at their respective intersections.</figcaption>
    </div>
	<br>
	<i>One Bounce Radiance - Light Importance Sampling</i><br>
	</p>
    <p>
        Overall, the <code>estimate_direct_lighting_importance</code> function is similar in structure to <code>estimate_direct_lighting_hemisphere</code>. However, there are some key differences. The function iterates over every light in the scene, and samples them each at a time. If the light is a delta light, then it is only sampled once before iterating to the next light, but if it is not a delta light then it is sampled multiple times according to the <code>-l</code> flag. The ray that is sent to sample the light is also done so directly to the light, and the direction is taken by using the <code>SceneLight::sample_L</code> function. <code>SceneLight::sample_L</code> is similar to <code>BSDF::sample_F</code>, and returns/edits many of the same variables, but takes in the point from which the ray originated, and returns the distance to the light itself alongside the radiance and direction. The distance to the light is taken into consideration, and the returned radiance of the light is divided by this distance to emulate real life light falloff.
    </p>

    <p>The new ray that is sent towards the light is also a "shadow ray." The light calculations are only performed if the ray <i>doesn't</i> intersect a scene object. If a scene object is intersected, then no radiance is added for the current sample. The shadow ray is created by setting the <code>max_t</code> for the ray to be the distance to the light, minus a small delta. This means that the light itself is never sampled directly, as the information required to calculate the radiance was already retrieved from the <code>sample_L</code> function call.
    </p>

    <p>Lastly, when calculating the irradiance from each light, the type of light is considered, just as with uniform hemisphere sampling. Delta lights don't need to be divided by the number of samples per area light. Infinite Hemisphere and Directional lights both don't have a valid distance to light, so light falloff isn't considered. Point lights and Area lights do, and so falloff is considered.
    </p>

    <h3>
        Show some images rendered with both implementations of the direct lighting function.
    </h3>
    <!-- Example of including multiple figures -->
    <div align="middle">
        <table style="width:100%">
            <!-- Header -->
            <tr align="center">
                <th>
                    <b>Uniform Hemisphere Sampling</b>
                </th>
                <th>
                    <b>Light Sampling</b>
                </th>
            </tr>
            <br>
            <tr align="center">
                <td>
                    <img src="images/p3_bunny_uniform.png" align="middle" width=90%;"/>
                    <figcaption>CBbunny.dae, Uniform Lighting</figcaption>
                </td>
                <td>
                    <img src="images/p3_bunny_direct.png" align="middle" width="90%;"/>
                    <figcaption>CBbunny.dae, Importance Lighting</figcaption>
                </td>
            </tr>
            <br>
            <tr align="center">
                <td>
                    <img src="images/p3_spheres_uniform.png" align="middle" width="90%;"/>
                    <figcaption>CBspheres_lambertian.dae, Uniform Lighting</figcaption>
                </td>
                <td>
                    <img src="images/p3_spheres_direct.png" align="middle" width="90%;"/>
                    <figcaption>CBspheres_lambertian.dae, Importance Lighting</figcaption>
                </td>
            </tr>
            <br>
        </table>
    </div>
	<p align="center">All images shown above were rendered using <code>-s 64</code> and <code>-l 32</code>.</p>
    <br>

    <h3>
        Focus on one particular scene with at least one area light and compare the noise levels in <b>soft
        shadows</b> when rendering with 1, 4, 16, and 64 light rays (the -l flag) and with 1 sample per pixel (the
        -s flag) using light sampling, <b>not</b> uniform hemisphere sampling.
    </h3>

    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/p3_spheres_l1.png" align="middle" width="90%;"/>
                    <figcaption>1 Light Ray (CBspheres_lambertian.dae)</figcaption>
                </td>
                <td>
                    <img src="images/p3_spheres_l4.png" align="middle" width="90%;"/>
                    <figcaption>4 Light Ray (CBspheres_lambertian.dae)</figcaption>
                </td>
            </tr>
            <tr align="center">
                <td>
                    <img src="images/p3_spheres_l16.png" align="middle" width="90%;"/>
                    <figcaption>16 Light Rays (CBspheres_lambertian.dae)</figcaption>
                </td>
                <td>
                    <img src="images/p3_spheres_l64.png" align="middle" width="90%;"/>
                    <figcaption>64 Light Rays (CBspheres_lambertian.dae)</figcaption>
                </td>
            </tr>
        </table>
    </div>

    <p>
        For all the images, the shadows can be seen as much more intense in the centre, and softening towards the edge. For the case with a single light sample (<code>-l 1</code>), because each pixel only has 1 sample and 1 light sample, the shadows were either at full intensity or not present at all. This is due to there being a singular light sample ray, meaning that the light was either reached or not. This leads to a speckled look, but from a distance it still gives the appearance of a shadow gradually softening out. As light samples increased, the shadows became softer and more gradual, and this is most obvious in the <code>-l 64</code> image.
    </p>
    <br>

    <h3>
        Compare the results between uniform hemisphere sampling and lighting sampling in a one-paragraph analysis.
    </h3>
    <p>
        Most noticeably, the importance sampling results contained much less noise for a given pixel sample and light sample rate. More subtly, highlights in the importance sampled images reached "further down" away from the light than in the uniform images. Notice that on the importance sampled spheres, especially the right sphere, around half of the sphere is lit. In comparison, the uniform sampled spheres have a much smaller lit portion. This is also noticeable in the top corners of the room where it meets the roof. This makes sense, as in a uniformly sampled approach, sampling an area that has a near perpendicular angle to the light has an improbably chance of hitting the light. By targeting the light itself, importance sampling allows these near perpendicular regions to receive lighting. These effects are also visible on the bunny, and are noted below.
    </p>

	<div align="middle">
		<img src="images/p3_comp.png" align="middle" width="50%"/>
		<figcaption>1 Light Ray (CBspheres_lambertian.dae)</figcaption>
    </div>

    <br>


    <h2 align="middle">Part 4: Global Illumination (20 Points)</h2>
   <!--
    Pick one scene and compare rendered views first with only direct illumination, then only indirect illumination. Use 1024 samples per pixel. (You will have to edit PathTracer::at_least_one_bounce_radiance(...) in your code to generate these views.)
    For CBbunny.dae, compare rendered views with max_ray_depth set to 0, 1, 2, 3, and 100 (the -m flag). Use 1024 samples per pixel.
    Pick one scene and compare rendered views with various sample-per-pixel rates, including at least 1, 2, 4, 8, 16, 64, and 1024. Use 4 light rays.
    You will probably want to use the instructional machines for the above renders in order to not burn up your own computer for hours. -->

    <h3>
        Walk through your implementation of the indirect lighting function.
    </h3>

    <!-- Walk through your implementation of the indirect lighting function.
   Show some images rendered with global (direct and indirect) illumination. Use 1024 samples per pixel.-->
   <p>Global illumination consists of direct and indirect light. The indirect lightning comes from light bouncing off objects in the scene several times before reaching the camera. We implemented global illumination by adding together zero-bounce (direct) and the at-least-one-bounce radiance (indirect). The zero-bounce radiance displays light directly from the light source. The at-least-one-bounce-radiance collects and displays light by adding radiance from rays bouncing at least once and bouncing multiple times, until a termination condition is reached. We used recursion to implement <code>at_least_one_bounce_radiance</code> and used the Russian Roulette as the unbiased probabilistic termination condition. The Russian Roulette ensures that all rays stop. We set the probability of stopping to 0.3. The rays also stop if they reach their maximum depth, to avoid long termination times. The <code>at_least_one_bounce_radiance</code> function never actually tries to sample a light source itself, and calls the <code>one_bounce_radiance</code> to sample radiance. We decrement the ray's depth on each recursive call, so the recursion collects the radiance from the point of the last ray's intersection (the maximum depth), and then adds the radiance as it recurses back up the stack, until the initial <code>at_least_one_bounce_radiance</code> call is reached. </p>

    <p>For each pixel, on each recursive call, we collect the amount of light at each bounce, then add the light from all bounces together to get the overall global illumination. We recursively create new rays at each intersection point (bounce), until the ray stops either by reaching the maximum depth or by the Russian Roulette (the coin flip, which returns a boolean that stops the recursion).</p>

    <h3>
        Show some images rendered with global (direct and indirect) illumination. Use 1024 samples per pixel.
    </h3>

    <p>Images below show global illumination and were rendered using 1024 samples per pixel and 4 light rays. Both images are 480x360 pixels. The maximum ray depth was set to 5.</p>

    <div align="middle">
        <table style="width:100%">
            <tr align="center" width="100%;">
                <td width="50%;">
                    <img src="images/t4_spheres_1024.png" align="middle" width="90%;"/>
                    <figcaption>Global Illumination Example (<code>CBspheres_lambertian.dae</code>)</figcaption>
                </td>
                <td width="50%;">
                    <img src="images/t4_cbbunny_1024.png" align="middle" width="90%;"/>
                    <figcaption>Global Illumination Example (<code>CBbunny.dae</code>)</figcaption>
                </td>
            </tr>
        </table>
    </div>

    <h3>
        Pick one scene and compare rendered views first with only direct illumination, then only indirect
        illumination. Use 1024 samples per pixel.
    </h3>

   <p>
       To compare direct illumination with indirect illumination, we picked a scene with two spheres (<code>CBspheres_lambertian.dae</code>). First, we rendered the scene with direct illumination only, by collecting light from the light source in the <code>zero_bounce_radiance</code> and a modified <code>at_least_one_bounce_radiance</code> function. We modified the code in <code>at_least_one_bounce_radiance</code> to return after 1 bounce (at the ray depth of 1), in practice producing the same effect as calling the non-recursive <code>one_bounce_radiance</code> function. For indirect illumination only, we modified the total illumination to include the light from <code>at_least_one_bounce_radiance</code> but end when the ray depth is at 1. The indirect light doesn't include the light that comes directly from the light source, or the light from the first bounce. We calculate the illumination value by solving the reflectance equation using Monte Carlo Estimator. To get the radiance at the intersection point, we multiply the value of the recursive call of the newly created ray, the BSDF of the original intersection, the cosine of the angle between the incoming light and the normal to the object's surface, and divide by the probability distribution function.
   </p>

    <p>See below for comparison images, generated at 480x360 pixel resolution, 1024 samples per pixel, and 4 light rays. The maximum ray depth for indirect illumination was set to 5.</p>

    <div align="middle">
        <table style="width:100%">
            <tr align="center" width="100%;">
                <td width="50%;">
                    <img src="images/t4_spheres_direct_1024.png" align="middle" width="90%;"/>
                    <figcaption>Direct Illumination Example (<code>CBspheres_lambertian.dae</code>)</figcaption>
                </td>
                <td width="50%;">
                    <img src="images/t4_spheres_indirect_1024.png" align="middle" width="90%;"/>
                    <figcaption>Indirect Illumination Example (<code>CBspheres_lambertian.dae</code>)</figcaption>
                </td>
            </tr>
        </table>
    </div>

    <p>In the direct illumination only (left picture above), we see the light that goes directly from the light into the camera (zero bounce) and light that bounces off objects once before hitting the camera. That's why we see the spheres illuminated from the top and not from the bottom. In the indirect illumination (right picture above), there's no direct light, so the ceiling is completely dark. Moreover, the spheres are not illuminated from above because we see only the light that bounces more than once. The overall indirect illumination images is darker than direct illumination image. Except for the colored shadows, the indirect illumination has almost no color, compared to the direct illumination image. Both images were rendered at 480x360 pixel resolution, 1024 samples per pixel, and 4 light rays. For indirect illumination, the maximum ray depth was 5.</p>

    <h3>
        For CBbunny.dae, compare rendered views with max_ray_depth set to 0, 1, 2, 3, and 100 (the -m flag). Use
        1024 samples per pixel.
    </h3>

    <p>
        Images below show the same image (<code>CBbunny.dae</code>) rendered with 1024 samples per pixel, 4 light rays, in a 480x360 size with various maximum ray depths, starting at 0 max ray depth up to 100.
    </p>


   <br><br>

    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/t4_CBbunny_m0.png" align="middle" width="75%;"/>
                    <figcaption>max_ray_depth = 0 (CBbunny.dae)</figcaption>
                </td>
                <td>
                    <img src="images/t4_CBbunny_m1.png" align="middle" width="75%;"/>
                    <figcaption>max_ray_depth = 1 (CBbunny.dae)</figcaption>
                </td>
            </tr>
            <tr align="center">
                <td>
                    <img src="images/t4_CBbunny_m2.png" align="middle" width="75%;"/>
                    <figcaption>max_ray_depth = 2 (CBbunny.dae)</figcaption>
                </td>
                <td>
                    <img src="images/t4_CBbunny_m3.png" align="middle" width="75%;"/>
                    <figcaption>max_ray_depth = 3 (CBbunny.dae)</figcaption>
                </td>
            </tr>
            <tr align="center">
                <td>
                    <img src="images/t4_CBbunny_m100.png" align="middle" width="75%;"/>
                    <figcaption>max_ray_depth = 100 (CBbunny.dae)</figcaption>
                </td>
            </tr>
        </table>
    </div>

    <br>

    <p>
        As seen in the images above, the 0 max ray depth is the zero-bounce direct illumination, where the only light visible is the light emitted by the light source. The 1 max ray depth is the one-bounce direct illumination, where the light that's visible is the light from the light source and the light that bounces off objects once, before reaching the camera. The max ray depth 2, 3, and 100 rely on the recursive at-least-one-bounce function, and include both direct and indirect illumination. As the ray max depth increases, the amount of total light in the image increases, so the images become brighter as the max depth increases. The last image with max depth ray 100 has the most light and more colored light because more light bouncing off the colored walls is included in the total light calculation. The 100 max ray depth took the longest to render, around 5 minutes, whereas the other images took seconds.
    </p>

    <br>

    <h3>
        Pick one scene and compare rendered views with various sample-per-pixel rates, including at least 1, 2, 4, 8, 16, 64, and 1024. Use 4 light rays.
    </h3>

    <p>We picked <code>CBspheres_lambertian.dae</code> to compare rendered views with different sample per pixel rates. In the images below, all images were rendered with global illumination using 480x360 pixel resolution, 4 light rays, and 5 maximum ray depth. The sample rate varied from 1 to 2048.</p>

    <br>

    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/t4_CBspheres_s1.png" align="middle" width="75%;"/>
                    <figcaption>1 sample per pixel (<code>CBspheres_lambertian.dae</code>)</figcaption>
                </td>
                <td>
                    <img src="images/t4_CBspheres_s2.png" align="middle" width="75%;"/>
                    <figcaption>2 samples per pixel (<code>CBspheres_lambertian.dae</code>)</figcaption>
                </td>
            </tr>
            <tr align="center">
                <td>
                    <img src="images/t4_CBspheres_s4.png" align="middle" width="75%;"/>
                    <figcaption>4 samples per pixel (<code>CBspheres_lambertian.dae</code>)</figcaption>
                </td>
                <td>
                    <img src="images/t4_CBspheres_s8.png" align="middle" width="75%;"/>
                    <figcaption>8 samples per pixel (<code>CBspheres_lambertian.dae</code>)</figcaption>
                </td>
            </tr>
            <tr align="center">
                <td>
                    <img src="images/t4_CBspheres_s16.png" align="middle" width="75%;"/>
                    <figcaption>16 samples per pixel (<code>CBspheres_lambertian.dae</code>)</figcaption>
                </td>
                <td>
                    <img src="images/t4_CBspheres_s64.png" align="middle" width="75%;"/>
                    <figcaption>64 samples per pixel (<code>CBspheres_lambertian.dae</code>)</figcaption>
                </td>
            </tr>
            <tr align="center">
                <td>
                    <img src="images/t4_CBspheres_s1024.png" align="middle" width="75%;"/>
                    <figcaption>1024 samples per pixel (<code>CBspheres_lambertian.dae</code>)</figcaption>
                </td>
                <td>
                    <img src="images/t4_CBspheres_s2048.png" align="middle" width="75%;"/>
                    <figcaption>2048 samples per pixel (<code>CBspheres_lambertian.dae</code>)</figcaption>
                </td>
            </tr>
        </table>
    </div>
    <br>

    <p>
        Images above illustrate the Monte Carlo Estimator in action. When we use 1 sample per pixel, the image is grainy and has a lot of noise, but is still realistically rendered with a good amount of light. However, since there's only 1 random sample per pixel, the approximation of the color in each pixel in the image is not accurate. With 2 samples per pixel, our image becomes less noisy, but it is still quite grainy. In particular, the spheres where there's light-to-dark transition look very choppy (the transition is not smooth). With 4 and 8 sampler per pixel, the transitions become smoother, but you can still see a lot of noise in flat surfaces like the ceiling and in the areas of fast color change like the bottom of the closer sphere. The 16 samples per pixel, most of the noise is in these transition areas. With 64 samples per pixel, most of the noise from flat surfaces is gone but there are still a few grainy areas on the spheres. With 1024 the image looks smooth with no grainy or noise appearance. Overall, even the 1 sample per pixel rendering captures the areas where there's a lot of light (the top of the spheres directly facing the light) and where there's a lot of shadow (underneath the spheres). The images get progressively less grainy and more smooth as the sample rate increases, with 64 samples showing some noise and 1024 having imperceptible amount of noise. The 2048 samples per pixel looks very close to the 1024 samples per pixel because our estimation of light converges to the true solution, so the difference in pixel color value is barely noticeable.
    </p>
    <br>


    <h2 align="middle">Part 5: Adaptive Sampling (20 Points)</h2>
    <!-- Explain adaptive sampling. Walk through your implementation of the adaptive sampling.
    Pick one scene and render it with at least 2048 samples per pixel. Show a good sampling rate image with clearly visible differences in sampling rate over various regions and pixels. Include both your sample rate image, which shows your how your adaptive sampling changes depending on which part of the image you are rendering, and your noise-free rendered result. Use 1 sample per light and at least 5 for max ray depth. -->

    <h3>
        Explain adaptive sampling. Walk through your implementation of the adaptive sampling.
    </h3>

	<p>
        Adaptive sampling is a technique to reduce the amount of noise produced by the Monte Carlo Estimator, seen in Parts 3 and 4. Rather than sampling every part of the image uniformly, adaptive sampling gets more samples from the regions that are more difficult to render. To determine which regions are more difficult to sample, we use statistical approach to measure each pixel's convergence, given by the formula below. The sigma is the variance and n is the number of samples. We check the convergence against a maximum tolerance times the mean of that pixel's value, calculated as the average of the n samples.
    </p>

    <div align="middle">
        <img src="images/t5_convergence_formula.png" align="middle" width="20%"/>
        <figcaption>Pixel convergence formula (credit: <a href="https://cs184.eecs.berkeley.edu/sp23/docs/proj3-1-part-5" target="_blank">Project Spec</a>).</figcaption>
    </div>


    <p>In the <code>PathTracer::raytrace_pixel</code>, we calculate the convergence of each pixel <code>n</code> times, where <code>n</code> is the number of samples. We find the illuminance for every sample and for every <code>samplesPerBatch</code>, we find statistical mean and standard deviation. We then check if the pixel value converges as 1.96 times the standard deviation divided by the square root of the variance. If the pixel converges, we stop calculating its radiance and add it to the overall radiance integral.</p>

    <br>

    <h3>
        Pick two scenes and render them with at least 2048 samples per pixel. Show a good sampling rate image with clearly visible differences in sampling rate over various regions and pixels. Include both your sample rate image, which shows your how your adaptive sampling changes depending on which part of the image you are rendering, and your noise-free rendered result. Use 1 sample per light and at least 5 for max ray depth.
    </h3>
    <!-- Example of including multiple figures -->
    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/p5_bunny.png" align="middle" width="75%;"/>
                    <figcaption>Rendered image (CBbunny.dae)</figcaption>
                </td>
                <td>
                    <img src="images/p5_bunny_rate.png" align="middle" width="75%;"/>
                    <figcaption>Sample rate image (CBbunny.dae)</figcaption>
                </td>
            </tr>
            <tr align="center">
                <td>
                    <img src="images/p5_bench.png" align="middle" width="75%;"/>
                    <figcaption>Rendered image (bench.dae)</figcaption>
                </td>
                <td>
                    <img src="images/p5_bench_rate.png" align="middle" width="75%;"/>
                    <figcaption>Sample rate image (bench.dae)</figcaption>
                </td>
            </tr>
        </table>
    </div>
	<p>
	Unfortunately, our implementation did not exactly match the reference solution images in the spec. However, we can clearly see that areas that have either full light or no light are fully blue, meaning they converged quickly. This is seen with the areas outside of the box and the bench, as well as the top of the bunny. The most sampled areas are the red, and those are the ones that are in the shade. This makes sense, as these darker areas have the most potential to change in lighting depending on where the indirect bounces go.
	</p>

    <br>


	<p>This project was a team effort. We worked on each part by ourselves first, then met to discuss the solution. When we encountered bugs or were unsure about the concepts, we worked on the code together. In the end, we each worked on all parts of the project, either as the main author or as a debugger. We pair-programmed the more difficult parts of the project, such as part 3.3. We both contributed to the project write-up, checking our understanding of all parts of this project. If someone coded more of the implementation for a certain part or function, we alternated the writeup, so that the person who didn't write the bulk of the code could have a chance to read through and understand the code. Overall, it was both challenging and rewarding.</p>

	<h3 align="middle">Website URL: <a href="https://irina694.github.io/cs284-sp23-projects/proj3-1/">https://irina694.github.io/cs284-sp23-projects/proj3-1</a>
	</h3>


</div>
</body>
</html>